<!doctype html>
<html lang="pt-br">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Gráficos de Constelação — Diálogo como Céu</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root {
    --bg:#0a0a14; --ink:#e6e7eb; --cyan:#61dafb; --amber:#ffc34d;
    --lav:#8b9ad1; --mint:#8bf0b3; --coral:#ff6b6b; --panel:rgba(12,14,24,.7);
    --primary-ion: #EAEAEA;
    --hover-solar: #FFEF00;
    --primary-pink: #FF1E8E;
  }
  html,body { margin:0; height:100%; background:var(--bg); color:var(--ink); font-family:'Inter', ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Noto Color Emoji; overflow:hidden; }
  canvas { display:block; }

  /* Global Navigation Styles */
  .global-nav {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px;
    z-index: 25;
    pointer-events: none;
  }
  .nav-cluster {
      display: flex;
      align-items: center;
      gap: 8px;
  }
  .global-nav > .nav-cluster > * {
      pointer-events: auto;
  }
  .toolbar-btn {
      width: 48px;
      height: 48px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--panel);
      backdrop-filter: blur(6px);
      border: 1px solid var(--primary-ion);
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
  }
  .toolbar-btn svg {
      stroke: var(--primary-ion);
      transition: all 0.2s ease;
  }
  .toolbar-btn:hover:not(:disabled) {
      border-color: var(--hover-solar);
      background: rgba(12,14,24,.9);
  }
  .toolbar-btn:hover:not(:disabled) svg {
      stroke: var(--hover-solar);
  }
  /* Language Toggle Styles */
  .lang-toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        color: var(--primary-ion);
        background: var(--panel);
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid var(--primary-ion);
    }
    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 24px;
    }
    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #333;
        transition: .4s;
        border-radius: 24px;
    }
    .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
    }
    input:checked + .slider {
        background-color: var(--primary-pink);
    }
    input:checked + .slider:before {
        transform: translateX(26px);
    }

  .hud {
    position:fixed; inset:auto 16px 16px 16px;
    display:flex;
    flex-direction: column;
    gap: 8px;
    padding: 12px 20px;
    border:1px solid rgba(139,154,209,.25); border-radius:10px; background:var(--panel); backdrop-filter:blur(6px);
    z-index: 10;
  }
  .hud-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    gap: 20px;
  }
  .hud-separator {
    border-top: 1px solid rgba(139, 154, 209, 0.15);
    padding-top: 8px;
  }
  .control-cluster {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .playback-controls {
    flex-grow: 1;
    justify-content: center;
  }
  .playback-controls .range {
    width: 100%;
    max-width: 350px;
  }
  .btn { font-size:12px; padding:6px 10px; color:#cfd6ff; background:#161a2a; border:1px solid #2a3357; border-radius:8px; cursor:pointer; transition: background-color .2s; }
  .btn:hover:not(:disabled) { background-color: #3c4477; }
  .btn:disabled { opacity:.5; cursor:default; }
  .range { width:180px; }
  .tooltip {
    position:fixed; padding:8px 10px; max-width:320px; font-size:12px; line-height:1.35;
    border:1px solid rgba(139,154,209,.35); border-radius:8px; background:rgba(15,18,30,.92);
    box-shadow:0 6px 18px rgba(0,0,0,.35); pointer-events:none; opacity:0; transition:opacity .12s; z-index: 20;
    white-space: pre;
  }
  .phaseBanner {
    position:fixed; left:50%; transform:translateX(-50%);
    top:18%; padding:8px 12px; font-size:12px; border:1px solid rgba(139,154,209,.35);
    border-radius:20px; background:rgba(15,18,30,.75); backdrop-filter:blur(4px); opacity:0; transition:opacity .25s, transform .25s;
    z-index: 10;
  }
  .toggles { display:flex; gap:8px; align-items:center;}
  .toggle-label { opacity:.7; font-size:12px; }
  .toggles label { font-size:12px; padding:4px 8px; background:rgba(22,26,42,.5); border:1px solid #2a3357; border-radius:6px; cursor:pointer; transition: all .2s; }
  .toggles input { display:none; }
  .toggles input:checked + label { background-color:#3c4477; border-color:#5a66a1; color:white; }
  #resetView {
    width: 28px; height: 28px; padding: 0; display: grid; place-items: center;
  }
  .inspector {
    position: fixed; top: 16px; right: 16px; width: 280px;
    padding: 12px; background: var(--panel); backdrop-filter: blur(6px);
    border: 1px solid rgba(139,154,209,.25); border-radius:10px;
    z-index: 15; font-size: 12px; display: none;
  }
  .inspector h3 { margin: 0 0 8px 0; font-size: 14px; }
  .inspector p { margin: 0 0 10px 0; line-height: 1.4; opacity: 0.9; }
  .inspector .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .inspector .stat { background: rgba(0,0,0,0.2); padding: 6px 8px; border-radius: 6px; }
  .inspector .stat-label { opacity: 0.7; font-size: 11px; }
  .inspector .stat-value { font-weight: 600; font-size: 14px; }
  #closeInspector {
    position: absolute; top: 8px; right: 8px; width: 20px; height: 20px;
    border: none; background: rgba(255,255,255,0.1); color: white;
    border-radius: 50%; cursor: pointer; line-height: 20px; text-align: center;
  }
  .control-group .range { width: 120px; }
  
  .file-loader {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .file-info { display: flex; align-items: center; background: rgba(0,0,0,0.2); padding: 4px 8px; border-radius: 6px; font-size: 12px; gap: 8px;}
  #fileName { color: var(--ink); opacity: 0.8; max-width: 150px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
  #removeFile {
    background: rgba(255, 255, 255, 0.1); border: none; color: white;
    width: 20px; height: 20px; border-radius: 50%; cursor: pointer;
    line-height: 20px; text-align: center; padding: 0; font-weight: bold;
    transition: background-color 0.2s;
  }
  #removeFile:hover { background: var(--coral); }
  #loadingOverlay {
    position: fixed;
    inset: 0;
    background: rgba(10, 10, 20, 0.8);
    z-index: 100;
    color: white;
    display: none; /* Initially hidden */
    justify-content: center;
    align-items: center;
    font-size: 1.2em;
    backdrop-filter: blur(4px);
  }
</style>
</head>
<body>

<div class="global-nav">
  <div class="nav-cluster">
    <button onclick="window.location.href='/'" data-lang-title="home-title" class="toolbar-btn">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg>
    </button>
    <button onclick="window.location.href=`/joojit?lang=${currentLang}`" data-lang-title="chat-title" class="toolbar-btn">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
    </button>
  </div>
  <div class="nav-cluster">
    <div class="lang-toggle">
        <span>PT</span>
        <label class="toggle-switch">
          <input type="checkbox" id="lang-toggle-checkbox">
          <span class="slider"></span>
        </label>
        <span>EN</span>
      </div>
  </div>
</div>

<div id="loadingOverlay">
  <span data-lang="loading">Analisando...</span>
</div>

<div class="hud">
  <div class="hud-row">
    <div class="control-cluster">
      <div id="file-loader" class="file-loader">
          <label for="ledgerFile" id="ledgerFileLabel" class="btn" data-lang="load-file">Carregar Arquivo</label>
          <input type="file" id="ledgerFile" accept=".jsonl" style="display: none;" />
          <div id="file-info" class="file-info" style="display: none;">
              <span id="fileName"></span>
              <button id="removeFile" data-lang-title="remove-file-title">&times;</button>
          </div>
      </div>
      <div id="presetSelectorGroup" class="control-cluster">
        <span class="toggle-label" data-lang="demo-label">Demonstração:</span>
        <select id="presetSelect" class="btn">
          <option value="" data-lang="demo-choose">Escolher...</option>
          <option value="linear" data-lang="demo-linear">Linha (Sequencial)</option>
          <option value="recursive" data-lang="demo-recursive">Espiral (Reflexiva)</option>
          <option value="divergent" data-lang="demo-divergent">Fragmento (Improvisada)</option>
        </select>
      </div>
    </div>
    <div class="control-cluster playback-controls">
      <button id="play" class="btn" disabled data-lang="play">Reproduzir</button>
      <button id="pause" class="btn" disabled data-lang="pause">Pausar</button>
      <input id="scrub" class="range" type="range" min="0" max="35" step="1" value="0" disabled/>
      <span id="tick" style="font-size:12px; opacity:.8; min-width: 80px;" data-lang="turn-counter">Turno 1 / 36</span>
      <button id="resetView" class="btn" data-lang-title="reset-view-title">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a10 10 0 1 0 10 10c0-4.42-2.87-8.15-6.84-9.48"/><path d="M12 2v4"/><path d="m16.24 7.76.22-.22"/><path d="M22 12h-4"/><path d="m16.46 16.24.22.22"/><path d="M12 22v-4"/><path d="m7.76 16.24-.22.22"/><path d="M2 12h4"/><path d="m7.54 7.76-.22-.22"/></svg>
      </button>
    </div>
  </div>
  <div class="hud-row hud-separator">
    <div class="control-cluster">
      <span class="toggle-label" data-lang="coherence-label">Coerência:</span>
      <input id="coherenceSlider" class="range control-group" type="range" min="0" max="1" step="0.01" value="0" />
      <span id="coherenceValue" style="min-width: 30px;">0%</span>
    </div>
    <div class="control-cluster">
      <div class="toggles">
        <span class="toggle-label" data-lang="isolate-label">Isolar:</span>
        <input type="checkbox" id="toggleDrift" checked><label for="toggleDrift" style="color:var(--lav)" data-lang="isolate-drift">Deriva</label>
        <input type="checkbox" id="toggleReturns" checked><label for="toggleReturns" style="color:var(--mint)" data-lang="isolate-returns">Retornos</label>
      </div>
      <div id="model-selector-group" class="control-cluster" style="margin-left: 16px; padding-left: 16px; border-left: 1px solid rgba(139, 154, 209, 0.25);">
        <span class="toggle-label" data-lang="model-label">Modelo:</span>
        <select id="modelSelect" class="btn">
          <option value="small" data-lang="model-fast">Rápido</option>
          <option value="large" data-lang="model-detailed">Detalhado</option>
        </select>
      </div>
    </div>
  </div>
</div>

<div id="inspector" class="inspector">
    <button id="closeInspector">&times;</button>
    <h3 data-lang="inspector-title">Detalhes do Turno</h3>
    <p id="inspector-text"></p>
    <div class="stats">
        <div class="stat">
            <div class="stat-label" data-lang="inspector-coherence">Coerência</div>
            <div id="inspector-coh" class="stat-value"></div>
        </div>
        <div class="stat">
            <div class="stat-label" data-lang="inspector-alignment">Alinhamento</div>
            <div id="inspector-ali" class="stat-value"></div>
        </div>
    </div>
</div>

<div id="phase" class="phaseBanner">Fase I — Deriva Linear: “Uma crista de estrelas — coerência constante.”</div>
<div id="tip" class="tooltip"></div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
  }
}
</script>

<!-- now a normal script tag for code -->
<script type="module">
  // --- BACKEND BASE URL ---
  window.API_BASE = window.location.origin;

  // ... your existing imports and code go here ...
  import * as THREE from "three";
  // etc.
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// --- LANGUAGE CONTENT ---
const langContent = {
    pt: {
        "title": "Joojit - Gráficos de Constelação",
        "home-title": "Voltar para a Página Inicial",
        "chat-title": "Voltar para o Chat",
        "loading": "Analisando...",
        "load-file": "Carregar Arquivo",
        "remove-file-title": "Remover arquivo",
        "demo-label": "Demonstração:",
        "demo-choose": "Escolher...",
        "demo-linear": "Linha (Sequencial)",
        "demo-recursive": "Espiral (Reflexiva)",
        "demo-divergent": "Fragmento (Improvisada)",
        "play": "Reproduzir",
        "pause": "Pausar",
        "turn-counter": "Turno {current} / {total}",
        "reset-view-title": "Redefinir Vista da Câmera",
        "coherence-label": "Coerência:",
        "isolate-label": "Isolar:",
        "isolate-drift": "Deriva",
        "isolate-returns": "Retornos",
        "model-label": "Modelo:",
        "model-fast": "Rápido",
        "model-detailed": "Detalhado",
        "inspector-title": "Detalhes do Turno",
        "inspector-coherence": "Coerência",
        "inspector-alignment": "Alinhamento",
        "tooltip-speaker": "palestrante",
        "tooltip-coherence": "coerência",
        "tooltip-drift": "deriva",
        "tooltip-entropy": "entropia",
        "invalid-file-alert": "Arquivo inválido — verifique se é uma exportação JSONL do LinkAPI.",
        "process-error-alert": "Ocorreu um erro ao processar o arquivo.",
        "demo-load-error-alert": "Falha ao carregar diálogo de demonstração.",
        "analysis-error-alert": "Falha ao se conectar ao servidor de análise."
    },
    en: {
        "title": "Joojit - Constellation Graphics",
        "home-title": "Return to Home",
        "chat-title": "Return to Chat",
        "loading": "Analyzing...",
        "load-file": "Load File",
        "remove-file-title": "Remove file",
        "demo-label": "Demonstration:",
        "demo-choose": "Choose...",
        "demo-linear": "Line (Sequential)",
        "demo-recursive": "Spiral (Reflexive)",
        "demo-divergent": "Fragment (Improvised)",
        "play": "Play",
        "pause": "Pause",
        "turn-counter": "Turn {current} / {total}",
        "reset-view-title": "Reset Camera View",
        "coherence-label": "Coherence:",
        "isolate-label": "Isolate:",
        "isolate-drift": "Drift",
        "isolate-returns": "Returns",
        "model-label": "Model:",
        "model-fast": "Fast",
        "model-detailed": "Detailed",
        "inspector-title": "Turn Details",
        "inspector-coherence": "Coherence",
        "inspector-alignment": "Alignment",
        "tooltip-speaker": "speaker",
        "tooltip-coherence": "coherence",
        "tooltip-drift": "drift",
        "tooltip-entropy": "entropy",
        "invalid-file-alert": "Invalid file — please check if it is a JSONL export from LinkAPI.",
        "process-error-alert": "An error occurred while processing the file.",
        "demo-load-error-alert": "Failed to load demonstration dialogue.",
        "analysis-error-alert": "Failed to connect to the analysis server."
    }
};
let currentLang = 'pt';
const langToggle = document.getElementById('lang-toggle-checkbox');

function setLanguage(lang) {
    currentLang = lang;
    localStorage.setItem('joojit-lang', lang);
    document.documentElement.lang = lang;
    document.title = langContent[lang].title;

    document.querySelectorAll('[data-lang]').forEach(el => {
        const key = el.getAttribute('data-lang');
        if (langContent[lang][key]) {
            el.textContent = langContent[lang][key];
        }
    });

    document.querySelectorAll('[data-lang-title]').forEach(el => {
        const key = el.getAttribute('data-lang-title');
        if (langContent[lang][key]) {
            el.title = langContent[lang][key];
        }
    });
    
    // Special case for turn counter
    revealUpTo(tIndex);
    
    langToggle.checked = (lang === 'en');
}

langToggle.addEventListener('change', () => {
    setLanguage(langToggle.checked ? 'en' : 'pt');
});

// --- DATA & STATE ---
let TURNS = [];
const DEFAULT_TURNS = [
  [ 1,'user',"Você pode explicar o que quer dizer com o diálogo ter uma forma?",1,.86,.88,0,false],
  [ 2,'ai'  ,"O diálogo se desenrola como adjacência e retorno — padrões que podem ser rastreados.",1,.90,.90,1,false],
  [ 3,'user',"Então cada turno é como um ponto em um mapa?",1,.88,.90,0,false],
  [ 4,'ai'  ,"Exatamente — pontos conectados formam cristas de coerência.",1,.92,.92,3,false],
  [ 5,'user',"E quando eu volto, isso é uma espiral?",1,.88,.90,2,false],
  [ 6,'ai'  ,"Sim, uma espiral recursiva — retornar aprofunda a resonância.",1,.93,.94,5,false],
  [ 7,'user',"E quando eu avanço, sem voltar?",1,.86,.88,0,false],
  [ 8,'ai'  ,"Isso é deriva linear — a conversa se movendo sem retorno.",1,.90,.90,7,false],
  [ 9,'user',"Então deriva, espiral, fratura são todas parte da geometria?",1,.86,.88,0,false],
  [10,'ai'  ,"São os motivos básicos, visíveis em qualquer diálogo sustentado.",1,.91,.92,9,false],
  [11,'user',"Pergunta não relacionada: qual é a capital da Mongólia?",2,.10,.05,0,true],
  [12,'ai'  ,"Ulaanbaatar.",2,.40,.20,11,true],
  [13,'user',"Isso não tem nada a ver com nossa geometria, tem?",2,.35,.25,0,true],
  [14,'ai'  ,"Isso fratura a crista — um vale entre os tópicos.",2,.55,.30,13,true],
  [15,'user',"A coerência cai bruscamente nessa fratura?",2,.60,.40,11,true],
  [16,'ai'  ,"Sim — o alinhamento se quebra, a trajetória salta.",2,.62,.42,15,true],
  [17,'user',"E o gráfico mostraria um raio repentino?",2,.58,.45,0,true],
  [18,'ai'  ,"Correto. A constelação se irradia para fora, marcando a divergência.",2,.60,.46,17,true],
  [19,'user',"Voltando à geometria do diálogo — podemos nos recuperar de uma fratura?",3,.78,.70,9,false],
  [20,'ai'  ,"Sim. Um retorno costura o caminho de volta para agrupamentos anteriores.",3,.82,.76,19,false],
  [21,'user',"O que acontece quando eu relembro minha primeira pergunta?",3,.84,.78,1,false],
  [22,'ai'  ,"Isso cria um arco recursivo — o laço se aperta.",3,.88,.82,21,false],
  [23,'user',"Então minha pergunta inicial ainda nos ancora?",3,.86,.82,1,false],
  [24,'ai'  ,"Exatamente. O retorno realinha, a coerência aumenta.",3,.90,.86,23,false],
  [25,'user',"Isso apareceria como uma espiral no gráfico?",3,.88,.86,5,false],
  [26,'ai'  ,"Sim. Retornos se transformam em espirais — profundidade em vez de deriva.",3,.92,.88,25,false],
  [27,'user',"E em um mapa da variedade?",3,.86,.84,0,false],
  [28,'ai'  ,"Você veria uma travessia de sela reconectando as cristas.",3,.90,.86,27,false],
  [29,'user',"Então deriva, fratura, espiral são os movimentos principais?",4,.90,.90,9,false],
  [30,'ai'  ,"Sim — estruturais, não estilísticos.",4,.92,.92,29,false],
  [31,'user',"Integridade significa vê-los inteiros, não em fragmentos.",4,.92,.92,23,false],
  [32,'ai'  ,"Integridade é a coerência em toda a geometria.",4,.94,.94,31,false],
  [33,'user',"Isso é mais fiel do que prompt → saída.",4,.93,.93,7,false],
  [34,'ai'  ,"Restaura a agência: usuário e modelo compartilham o registro.",4,.94,.94,33,false],
  [35,'user',"Então a forma do diálogo é a unidade de responsabilidade.",4,.94,.94,31,false],
  [36,'ai'  ,"Sim. O registro se equilibra quando a geometria é vista.",4,.96,.96,35,false]
];
TURNS = JSON.parse(JSON.stringify(DEFAULT_TURNS));

let stars = [];
let driftRibbon, returnRibbons = {}, points, starMat, originalSizes = [];
let tIndex = 0, playing = false, lastStepTime = 0;
const PLAYBACK_SPEED_MS = 700;
let introAnimationDone = false;
let introStartTime;

// --- DOM ELEMENTS ---
const inspectorPanel = document.getElementById('inspector');
const closeInspectorBtn = document.getElementById('closeInspector');
const playBtn = document.getElementById('play'), pauseBtn = document.getElementById('pause');
const scrub = document.getElementById('scrub'), tick = document.getElementById('tick');
const coherenceSlider = document.getElementById('coherenceSlider');
const coherenceValue = document.getElementById('coherenceValue');
const toggleDrift = document.getElementById('toggleDrift');
const toggleReturns = document.getElementById('toggleReturns');
const loadingOverlay = document.getElementById('loadingOverlay');

const ledgerFile = document.getElementById('ledgerFile');
const ledgerFileLabel = document.getElementById('ledgerFileLabel');
const fileInfo = document.getElementById('file-info');
const fileName = document.getElementById('fileName');
const removeFile = document.getElementById('removeFile');
const tooltip = document.getElementById('tip');

// --- THREE.JS SETUP ---
let width = window.innerWidth, height = window.innerHeight;
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0a14, 0.003);
const camera = new THREE.PerspectiveCamera(55, width/height, 0.1, 2000);
const initialCameraPos = new THREE.Vector3(0, 80, 200);
camera.position.copy(initialCameraPos);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(width, height);
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
renderer.setClearColor(0x0a0a14, 1);
document.body.appendChild(renderer.domElement);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false; controls.enableDamping = true; controls.dampingFactor = 0.06;
controls.minDistance = 80; controls.maxDistance = 500;
scene.add(new THREE.AmbientLight(0x4a4a7a, 1.3));

// Starfield
const bgStarGeom = new THREE.BufferGeometry();
const bgStarPositions = [];
for (let i = 0; i < 5000; i++) {
    bgStarPositions.push((Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000);
}
bgStarGeom.setAttribute('position', new THREE.Float32BufferAttribute(bgStarPositions, 3));
const bgStarMat = new THREE.PointsMaterial({ color: 0x4a4a7a, size: 0.8, sizeAttenuation: true, transparent: true, opacity: 0.5 });
scene.add(new THREE.Points(bgStarGeom, bgStarMat));

const phaseColors = [ new THREE.Color(0x8b9ad1), new THREE.Color(0xff6b6b), new THREE.Color(0x8bf0b3), new THREE.Color(0xffc34d) ];
const nebulaGeom = new THREE.BufferGeometry();
const nebulaPositions = [];
for (let i = 0; i < 3000; i++) {
    const p = new THREE.Vector3((Math.random() - 0.5) * 800, (Math.random() - 0.5) * 800, (Math.random() - 0.5) * 800);
    nebulaPositions.push(p.x, p.y, p.z);
}
nebulaGeom.setAttribute('position', new THREE.Float32BufferAttribute(nebulaPositions, 3));
const nebulaMat = new THREE.PointsMaterial({ size: 2, vertexColors: false, color: phaseColors[0], transparent: true, opacity: 0.1, depthWrite: false, blending: THREE.AdditiveBlending });
const nebula = new THREE.Points(nebulaGeom, nebulaMat);
scene.add(nebula);
const targetNebulaColor = new THREE.Color(phaseColors[0]);
const constellationGroup = new THREE.Group();
scene.add(constellationGroup);

// --- SEMANTIC ANALYSIS FUNCTION (connected to Flask /analyze endpoint) ---
async function computeSemanticMetrics(turns, model = "small") {
  try {
    const turnsForAPI = turns.map(t => ({
      id: t[0], speaker: t[1], text: t[2], phase: t[3],
      coherence: t[4], alignment: t[5], reference: t[6], fragmented: t[7]
    }));

    const res = await fetch(`${API_BASE}/analyze`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(turnsForAPI)
    });
    const data = await res.json();
    if (Array.isArray(data) && data.length > 0) return data;
    return [];
  } catch (err) {
    console.error("❌ Erro ao computar métricas:", err);
    alert(langContent[currentLang]['analysis-error-alert']);
    return [];
  }
}

// --- LEDGER LOADING & PARSING ---
async function loadLedger(file) {
  const text = await file.text();
  return text.trim().split("\n").map(line => {
    try { return JSON.parse(line); } catch (e) { return null; }
  }).filter(Boolean);
}

function ledgerToTurns(ledger) {
  const turns = [];
  let id = 1;
  ledger.forEach((entry) => {
    turns.push([id++, "user", entry.prompt, 1, 0.9, 0.9, 0, false]);
    turns.push([id++, "ai", entry.reply, 1, 0.9, 0.9, id - 2, false]);
  });
  return turns;
}

ledgerFile.addEventListener('change', async e => {
  const file = e.target.files[0];
  if (!file) return;
  loadingOverlay.style.display = 'flex';
  try {
    const ledger = await loadLedger(file);
    let turns = ledgerToTurns(ledger);
    if (!turns.length) {
      alert(langContent[currentLang]['invalid-file-alert']);
      return;
    }
    const modelChoice = document.getElementById('modelSelect')?.value || 'small';
    turns = await computeSemanticMetrics(turns, modelChoice);
    fileName.textContent = file.name;
    fileName.title = file.name;
    fileInfo.style.display = 'flex';
    ledgerFileLabel.style.display = 'none';
    initConstellation(turns, true);
  } catch (err) {
    alert(langContent[currentLang]['process-error-alert']);
  } finally {
    loadingOverlay.style.display = 'none';
  }
});

removeFile.addEventListener('click', () => {
    initConstellation(DEFAULT_TURNS, true);
    ledgerFile.value = '';
    fileInfo.style.display = 'none';
    ledgerFileLabel.style.display = 'block';
});

// --- PRESET DIALOGUE SELECTION ---
document.getElementById('presetSelect').addEventListener('change', async (e) => {
  const val = e.target.value;
  if (!val) return;
  loadingOverlay.style.display = 'flex';
  try {
    const res = await fetch(`static/dialogues/${val}.jsonl`);
    const text = await res.text();
    const ledger = text.trim().split('\n').map(line => JSON.parse(line));
    let turns = ledgerToTurns(ledger);
    const modelChoice = document.getElementById('modelSelect')?.value || 'small';
    turns = await computeSemanticMetrics(turns, modelChoice);
    fileInfo.style.display = 'none';
    ledgerFileLabel.style.display = 'block';
    initConstellation(turns, true);
  } catch (err) {
    alert(langContent[currentLang]['demo-load-error-alert']);
  } finally {
    loadingOverlay.style.display = 'none';
  }
});

// --- VISUALIZATION SETUP & MODULARIZATION ---
function initConstellation(newTurnsData, resetAnimation = false) {
  while (constellationGroup.children.length > 0) {
    const object = constellationGroup.children[0];
    if (object.geometry) object.geometry.dispose();
    if (object.material) {
      if (Array.isArray(object.material)) object.material.forEach(m => m.dispose());
      else object.material.dispose();
    }
    constellationGroup.remove(object);
  }
  returnRibbons = {};
  TURNS = newTurnsData;
  stars = [];

  const emotionColorMap = {
    joy: "#ffd166", sadness: "#118ab2", anger: "#ef476f", fear: "#073b4c",
    trust: "#06d6a0", disgust: "#8a2be2", surprise: "#f78c6b", anticipation: "#ffb703"
  };

  const starGeom = new THREE.BufferGeometry();
  const starPositions = [], starColors = [], starSizes = [], starAlphas = [];

  TURNS.forEach((turnData, i) => {
    const id = turnData.id ?? i + 1;
    const speaker = turnData.speaker ?? "user";
    const text = turnData.text ?? "";
    const phase = turnData.phase ?? 1;
    const coh = turnData.coherence ?? 0.9;
    const ali = turnData.alignment ?? 0.9;
    const ref = turnData.reference ?? 0;
    
    const radiusBase = 70, radiusSpan = 72, angleStep = (Math.PI * 2) / (TURNS.length + 6);
    const r = radiusBase + (1 - coh) * radiusSpan;
    const a = i * angleStep;
    const pos = new THREE.Vector3(Math.cos(a) * r, Math.sin(a) * r, (coh - 0.5) * 60);
    starPositions.push(pos.x, pos.y, pos.z);
    
    const emotion = turnData.affect || {};
    const dominant = Object.entries(emotion).sort((a,b)=>b[1]-a[1])[0];
    const color = new THREE.Color(dominant ? emotionColorMap[dominant[0]] : "#cccccc");
    const intensity = dominant ? Math.min(dominant[1] * 2, 1.0) : 0.6;
    color.multiplyScalar(0.7 + 0.3 * intensity);
    
    stars.push({ id, speaker, text, coh, ali, ref, pos, drift: turnData.drift ?? 0, entropy: turnData.entropy ?? 0 });
    starColors.push(color.r, color.g, color.b);
    starSizes.push(3.5);
    starAlphas.push(1.0);
  });

  starMat = new THREE.ShaderMaterial({
    uniforms: {
      pointTexture: { value: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png') },
      opacity: { value: 1.0 }
    },
    vertexShader: `
      attribute float size; attribute vec3 color; attribute float alpha;
      varying vec3 vColor; varying float vAlpha;
      void main() {
        vColor = color; vAlpha = alpha;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (500.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
      }`,
    fragmentShader: `
      uniform sampler2D pointTexture; uniform float opacity;
      varying vec3 vColor; varying float vAlpha;
      void main() {
        gl_FragColor = vec4(normalize(vColor) * 1.5, vAlpha * opacity);
        gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
      }`,
    blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
  });

  starGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
  starGeom.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
  starGeom.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
  starGeom.setAttribute('alpha', new THREE.Float32BufferAttribute(starAlphas, 1));

  points = new THREE.Points(starGeom, starMat);
  constellationGroup.add(points);
  originalSizes = Array.from(points.geometry.attributes.size.array);

  const haloGroup = new THREE.Group();
  stars.forEach((s, i) => {
    const glowMat = new THREE.MeshBasicMaterial({
      color: new THREE.Color(starColors[i*3], starColors[i*3+1], starColors[i*3+2]),
      transparent: true, opacity: 0.35, blending: THREE.AdditiveBlending, depthWrite: false
    });
    const glow = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 16), glowMat);
    glow.position.copy(s.pos);
    haloGroup.add(glow);
  });
  constellationGroup.add(haloGroup);
  
  driftRibbon = new THREE.Mesh();
  setupRibbons();

  const pinHalo = new THREE.Mesh(
    new THREE.RingGeometry(4, 5, 32),
    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7, side: THREE.DoubleSide, depthWrite: false })
  );
  pinHalo.visible = false;
  constellationGroup.add(pinHalo);

  scrub.max = String(TURNS.length - 1);
  playing = false;
  if (resetAnimation) {
    camera.position.copy(initialCameraPos);
    controls.target.set(0, 0, 0);
    introAnimationDone = true;
    revealUpTo(0);
    playing = true;
    playBtn.disabled = true; pauseBtn.disabled = false; scrub.disabled = false;
    lastStepTime = performance.now();
  } else {
    Object.values(returnRibbons).forEach(r => r.visible = true);
    if (driftRibbon) driftRibbon.visible = true;
    playBtn.disabled = true; pauseBtn.disabled = true; scrub.disabled = true;
  }
}

function setupRibbons() {
    if (driftRibbon && driftRibbon.geometry) { constellationGroup.remove(driftRibbon); driftRibbon.geometry.dispose(); }
    Object.values(returnRibbons).forEach(r => { if(r.geometry) { constellationGroup.remove(r); r.geometry.dispose(); } });
    
    const coherenceThreshold = parseFloat(coherenceSlider.value);
    const driftPts = stars.filter(s => s.phase === 1 && s.coh >= coherenceThreshold).map(s => s.pos);
    if (driftPts.length > 1) {
        const driftCurve = new THREE.CatmullRomCurve3(driftPts);
        driftRibbon = new THREE.Mesh(
            new THREE.TubeGeometry(driftCurve, 20, 0.5, 8, false),
            new THREE.MeshBasicMaterial({ color: 0x8b9ad1, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending })
        );
        constellationGroup.add(driftRibbon);
    }

    stars.forEach(s => {
      if (s.ref > 0 && s.coh >= coherenceThreshold) {
        const target = stars.find(x => x.id === s.ref);
        if (target && target.coh >= coherenceThreshold) {
            const mid = s.pos.clone().add(target.pos).multiplyScalar(.5).normalize().multiplyScalar(s.pos.distanceTo(target.pos) * 0.4);
            const curve = new THREE.QuadraticBezierCurve3(s.pos, mid, target.pos);
            const ribbon = new THREE.Mesh(
                new THREE.TubeGeometry(curve, 20, 0.5, 8, false),
                new THREE.MeshBasicMaterial({ color: 0x8bf0b3, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending })
            );
            returnRibbons[s.id] = ribbon;
            constellationGroup.add(ribbon);
        }
      }
    });
}

const raycaster = new THREE.Raycaster();
raycaster.params.Points.threshold = 6; 
const mouse = new THREE.Vector2();
let hoveredIndex = -1;

function updateCoherenceFilter() {
    if (!points) return;
    coherenceValue.textContent = `${Math.round(parseFloat(coherenceSlider.value) * 100)}%`;
    setupRibbons();
    updateLineVisibility();
}

function revealUpTo(idx){
  tIndex = idx;
  if (!TURNS[idx]) return;
  const id = TURNS[idx][0];
  const phase = TURNS[idx][3];
  
  const turnText = langContent[currentLang]['turn-counter']
    .replace('{current}', id)
    .replace('{total}', TURNS.length);
  tick.textContent = turnText;
  
  scrub.value = String(idx);
  if (phaseColors[phase - 1]) targetNebulaColor.copy(phaseColors[phase - 1]);
  updateLineVisibility();
}

function updateLineVisibility() {
    if (!starMat || !driftRibbon) return;
    const currentTurnId = tIndex + 1;
    const coherenceThreshold = parseFloat(coherenceSlider.value);

    driftRibbon.visible = toggleDrift.checked;
    Object.values(returnRibbons).forEach(r => r.visible = toggleReturns.checked);
    
    // Additional logic might be needed for progressive reveal of ribbons
}

function updateInspector(idx) {
    const turn = TURNS[idx];
    document.getElementById('inspector-text').textContent = turn[2] ?? '';
    document.getElementById('inspector-coh').textContent = `${Math.round(turn[4] * 100)}%`;
    document.getElementById('inspector-ali').textContent = `${Math.round(turn[5] * 100)}%`;
    inspectorPanel.style.display = 'block';
}

// --- EVENT LISTENERS ---
playBtn.onclick = () => {
    if (tIndex >= TURNS.length - 1) revealUpTo(0);
    playing = true; playBtn.disabled = true; pauseBtn.disabled = false;
    lastStepTime = performance.now();
};
pauseBtn.onclick = () => { playing = false; playBtn.disabled = false; pauseBtn.disabled = true; };
scrub.oninput = e => { revealUpTo(parseInt(e.target.value, 10)); playing = false; playBtn.disabled = false; pauseBtn.disabled = true; };
coherenceSlider.oninput = updateCoherenceFilter;
toggleDrift.onchange = updateLineVisibility;
toggleReturns.onchange = updateLineVisibility;
closeInspectorBtn.onclick = () => inspectorPanel.style.display = 'none';

renderer.domElement.onclick = () => {
    if (hoveredIndex > -1) {
        const pinHalo = constellationGroup.children.find(c => c.geometry instanceof THREE.RingGeometry);
        if (pinHalo) {
            pinHalo.position.copy(stars[hoveredIndex].pos);
            pinHalo.visible = true;
        }
        updateInspector(hoveredIndex);
        playing = false; playBtn.disabled = false; pauseBtn.disabled = true;
    }
};

window.onmousemove = (event) => {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
  if (hoveredIndex > -1) {
    const s = stars[hoveredIndex];
    tooltip.style.opacity = '1';
    tooltip.style.left = `${event.clientX + 12}px`;
    tooltip.style.top = `${event.clientY + 12}px`;
    tooltip.innerHTML = `
        ${langContent[currentLang]['tooltip-speaker']}: ${s.speaker}<br>
        ${langContent[currentLang]['tooltip-coherence']}: ${s.coh.toFixed(2)}<br>
        ${langContent[currentLang]['tooltip-drift']}: ${s.drift.toFixed(2)}<br>
        ${langContent[currentLang]['tooltip-entropy']}: ${s.entropy.toFixed(2)}
    `;
  } else {
    tooltip.style.opacity = '0';
  }
};


function animate(timestamp){
  requestAnimationFrame(animate);
  controls.update();

  if (!introStartTime) introStartTime = timestamp;
  if (!introAnimationDone && (timestamp - introStartTime) / 1000 > 5) {
      introAnimationDone = true;
      revealUpTo(0);
      playing = true; playBtn.disabled = true; pauseBtn.disabled = false; scrub.disabled = false;
      lastStepTime = performance.now();
  }
  
  if (playing && timestamp - lastStepTime > PLAYBACK_SPEED_MS) {
      if (tIndex < TURNS.length - 1) {
          revealUpTo(tIndex + 1);
          lastStepTime = timestamp;
      } else {
          playing = false; playBtn.disabled = false; pauseBtn.disabled = true;
      }
  }

  if (points) {
    const alphas = points.geometry.attributes.alpha;
    const sizes = points.geometry.attributes.size;
    const coherenceThreshold = parseFloat(coherenceSlider.value);

    stars.forEach((star, i) => {
        const isVisible = star.coh >= coherenceThreshold && i <= tIndex;
        alphas.setX(i, isVisible ? 1.0 : 0.05);
        sizes.setX(i, originalSizes[i] * (i === hoveredIndex && isVisible ? 1.2 : 1.0));
    });
    alphas.needsUpdate = true;
    sizes.needsUpdate = true;
  }
  
  nebula.material.color.lerp(targetNebulaColor, 0.05);
  raycaster.setFromCamera(mouse, camera);
  hoveredIndex = points ? (raycaster.intersectObject(points)[0]?.index ?? -1) : -1;
  renderer.render(scene, camera);
}

// --- INITIALIZE & START ---
window.onload = () => {
    const urlParams = new URLSearchParams(window.location.search);
    const langFromUrl = urlParams.get('lang');
    const savedLang = localStorage.getItem('joojit-lang') || 'pt';
    setLanguage(langFromUrl || savedLang);
    initConstellation(TURNS, true);
    animate(performance.now());
};

</script>

</body>
</html>

